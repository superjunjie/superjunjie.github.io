<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Jerry's Bolg</title><meta name="author" content="Jerry"><meta name="copyright" content="Jerry"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta property="og:type" content="website">
<meta property="og:title" content="Jerry&#39;s Bolg">
<meta property="og:url" content="https://github.com/superjunjie/blog/index.html">
<meta property="og:site_name" content="Jerry&#39;s Bolg">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://github.com/superjunjie/blog/img/avatar.jpg">
<meta property="article:author" content="Jerry">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://github.com/superjunjie/blog/img/avatar.jpg"><link rel="shortcut icon" href="/superjunjie/blog/img/favicon.png"><link rel="canonical" href="https://github.com/superjunjie/blog/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/superjunjie/blog/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/superjunjie/blog/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Jerry\'s Bolg',
  isPost: false,
  isHome: true,
  isHighlightShrink: false,
  isToc: false,
  postUpdate: '2022-12-08 21:43:58'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/superjunjie/blog/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/superjunjie/blog/archives/"><div class="headline">Articles</div><div class="length-num">9</div></a><a href="/superjunjie/blog/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/superjunjie/blog/categories/"><div class="headline">Categories</div><div class="length-num">3</div></a></div><hr/></div></div><div class="page" id="body-wrap"><header class="full_page" id="page-header" style="background-image: url('/superjunjie/blog/img/bg_1.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/superjunjie/blog/">Jerry's Bolg</a></span><div id="menus"><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="site-info"><h1 id="site-title">Jerry's Bolg</h1><div id="site_social_icons"><a class="social-icon" href="https://github.com/superjunjie" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:pcxiaoyan@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div id="scroll-down"><i class="fas fa-angle-down scroll-down-effects"></i></div></header><main class="layout" id="content-inner"><div class="recent-posts" id="recent-posts"><div class="recent-post-item"><div class="post_cover left"><a href="/superjunjie/blog/2022/01/06/function-overloading/" title="函数重载实现"><img class="post_bg" src="/superjunjie/blog/./images/5.webp" onerror="this.onerror=null;this.src='/superjunjie/blog/img/404.jpg'" alt="函数重载实现"></a></div><div class="recent-post-info"><a class="article-title" href="/superjunjie/blog/2022/01/06/function-overloading/" title="函数重载实现">函数重载实现</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2022-01-06T00:00:00.000Z" title="Created 2022-01-06 08:00:00">2022-01-06</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/superjunjie/blog/categories/%E5%B7%A5%E5%85%B7%E6%96%B9%E6%B3%95/">工具方法</a></span></div><div class="content">利用闭包特性实现函数重载，实现原理是通过将每次添加的方法用一个变量联系起来，这相当与是一个链表，添加的最后一个方法作为链表的头节点，通过old这个next指针寻找下一个重载方法，直到找到满足条件的重载方法
12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// 为指定对象绑定方法namefunction addMethods(object, name, f) &#123;  // 获得该对象上的name方法，第一次进来为undefined    let old = object[name]    // 设置name方法    object[name] = function () &#123;        // 如果传入的函数f的参数与调用该name方法的传入的参数长度一样，返回调用f函数结果        if (f.length === arguments.length) &#123;            return ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/superjunjie/blog/2022/01/05/events-emitter/" title="发布订阅模式实现"><img class="post_bg" src="/superjunjie/blog/./images/4.webp" onerror="this.onerror=null;this.src='/superjunjie/blog/img/404.jpg'" alt="发布订阅模式实现"></a></div><div class="recent-post-info"><a class="article-title" href="/superjunjie/blog/2022/01/05/events-emitter/" title="发布订阅模式实现">发布订阅模式实现</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2022-01-05T00:00:00.000Z" title="Created 2022-01-05 08:00:00">2022-01-05</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/superjunjie/blog/categories/%E5%B7%A5%E5%85%B7%E6%96%B9%E6%B3%95/">工具方法</a></span></div><div class="content">实现一个发布订阅模式，要求具有下面功能：

订阅、发布事件的实现
支持单次订阅
支持取消订阅12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061class eventsEmitter &#123;    constructor() &#123;        this.events = &#123;&#125;    &#125;    // 实现订阅    on(type, cb) &#123;        if(!this.events[type]) &#123;            this.events[type] = [cb]        &#125; else &#123;            this.events[type].push(cb)        &#125;    &#125;    // 删除订阅    off(type, cb) &#123;        if(!this. ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/superjunjie/blog/2022/01/04/deep-clone/" title="深拷贝实现"><img class="post_bg" src="/superjunjie/blog/./images/3.webp" onerror="this.onerror=null;this.src='/superjunjie/blog/img/404.jpg'" alt="深拷贝实现"></a></div><div class="recent-post-info"><a class="article-title" href="/superjunjie/blog/2022/01/04/deep-clone/" title="深拷贝实现">深拷贝实现</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2022-01-04T00:00:00.000Z" title="Created 2022-01-04 08:00:00">2022-01-04</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/superjunjie/blog/categories/%E5%B7%A5%E5%85%B7%E6%96%B9%E6%B3%95/">工具方法</a></span></div><div class="content">实现一个深度拷贝方法，支持所有的引用对象深度克隆，包括数组，对象等
1234567891011121314151617181920212223242526272829303132333435363738394041424344function deepClone(obj, hash = new WeakMap()) &#123;    // 缓存对象，处理循环引用导致的问题    if (hash.has(obj)) &#123;        return obj    &#125;    // 初始化结果    let res = null    const reference = [Date, RegExp, Set, WeakSet, Map, WeakMap, Error]    if (reference.includes(obj?.constructor)) &#123;        // 判断是不是上述几种引用类型        res = new obj.constructor(obj)    &#125; else if (Array.isArray(obj))  ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/superjunjie/blog/2022/01/03/debounce-throttle/" title="节流防抖实现"><img class="post_bg" src="/superjunjie/blog/./images/2.webp" onerror="this.onerror=null;this.src='/superjunjie/blog/img/404.jpg'" alt="节流防抖实现"></a></div><div class="recent-post-info"><a class="article-title" href="/superjunjie/blog/2022/01/03/debounce-throttle/" title="节流防抖实现">节流防抖实现</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2022-01-03T00:00:00.000Z" title="Created 2022-01-03 08:00:00">2022-01-03</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/superjunjie/blog/categories/%E5%B7%A5%E5%85%B7%E6%96%B9%E6%B3%95/">工具方法</a></span></div><div class="content">函数防抖在事件被触发的n秒后在执行，如果在n秒内再次被触发，则需要重新计时
123456789const debounce = (fn, delay) =&gt; &#123;    let timer = null    return function() &#123;        timer &amp;&amp; clearTimeout(timer)        timer = setTimeout(() =&gt; &#123;            fn.apply(this, arguments)        &#125;, delay);    &#125;&#125;
个人理解 函数防抖就是法师发技能的时候要读条，技能读条没完再按技能就会重新读条。
函数节流高频时间触发，但n秒内只会执行一次，所以节流会稀释函数的执行频率
1234567891011const throttle = (fn, delay) =&gt; &#123;    let flag = true    return function() &#123;        if(!flag) retu ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/superjunjie/blog/2022/01/02/array-op/" title="数组方法实现"><img class="post_bg" src="/superjunjie/blog/./images/1.webp" onerror="this.onerror=null;this.src='/superjunjie/blog/img/404.jpg'" alt="数组方法实现"></a></div><div class="recent-post-info"><a class="article-title" href="/superjunjie/blog/2022/01/02/array-op/" title="数组方法实现">数组方法实现</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2022-01-02T00:00:00.000Z" title="Created 2022-01-02 08:00:00">2022-01-02</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/superjunjie/blog/categories/%E5%B7%A5%E5%85%B7%E6%96%B9%E6%B3%95/">工具方法</a></span></div><div class="content">数组降维递归方法12345678// 实现一个方法使多维数组变成一维数组function flatter(arr) &#123;    if (!arr.length) return    return arr.reduce((pre, cur) =&gt;        Array.isArray(cur) ? [...pre, ...flatter(cur)] : [...pre, cur],        []    )&#125;
Generator方法12345678910function* flatByGenerator(arr) &#123;    const length = arr.length    for (let i = 0; i &lt; length; i++) &#123;        if (Array.isArray(arr[i])) &#123;            yield* flatByGenerator(arr[i])        &#125; else &#123;            yield arr[i]        &#1 ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/superjunjie/blog/2022/01/02/jas/" title="异步驱动JAS实现"><img class="post_bg" src="/superjunjie/blog/./images/20220104132.webp" onerror="this.onerror=null;this.src='/superjunjie/blog/img/404.jpg'" alt="异步驱动JAS实现"></a></div><div class="recent-post-info"><a class="article-title" href="/superjunjie/blog/2022/01/02/jas/" title="异步驱动JAS实现">异步驱动JAS实现</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2022-01-02T00:00:00.000Z" title="Created 2022-01-02 08:00:00">2022-01-02</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/superjunjie/blog/categories/%E5%B7%A5%E5%85%B7%E6%96%B9%E6%B3%95/">工具方法</a></span></div><div class="content">实现一个不同于Promise的异步驱动模型Jas，这个函数要包含下面这些功能：

支持发布、订阅事件
支持同时订阅多个事件
支持链式调用
指定this对象123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899class Jas &#123;  constructor() &#123;    // 订阅唯一ID    this.uid = 1    // 收集订阅者信息    this.depMap = new Map()    // 收集事件信息    this.eventMap = new Map()  &#125;  // 订阅方法实现  when(resources, callback, thisObj) &#123;    // 输入参数格式化，支持单个或多个 ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/superjunjie/blog/2022/01/02/lru/" title="LRU缓存淘汰算法实现"><img class="post_bg" src="/superjunjie/blog/./images/6.webp" onerror="this.onerror=null;this.src='/superjunjie/blog/img/404.jpg'" alt="LRU缓存淘汰算法实现"></a></div><div class="recent-post-info"><a class="article-title" href="/superjunjie/blog/2022/01/02/lru/" title="LRU缓存淘汰算法实现">LRU缓存淘汰算法实现</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2022-01-02T00:00:00.000Z" title="Created 2022-01-02 08:00:00">2022-01-02</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/superjunjie/blog/categories/%E5%B7%A5%E5%85%B7%E6%96%B9%E6%B3%95/">工具方法</a></span></div><div class="content">123456789101112131415161718192021222324252627282930313233343536373839404142class LRUCache &#123;    constructor(capacity) &#123;        this.secretKey = new Map()        this.capacity = capacity    &#125;    get(key) &#123;        if(this.secretKey.has(key)) &#123;            let tempValue = this.secretKey.get(key)            this.secretKey.delete(key)            this.secretKey.set(key, tempValue)            return tempValue        &#125; else &#123;            return -1        &#125;    &#125;  ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/superjunjie/blog/2022/01/01/what-is-xss-csrf/" title="什么是XSS和CSRF攻击"><img class="post_bg" src="/superjunjie/blog/./images/20221108001.webp" onerror="this.onerror=null;this.src='/superjunjie/blog/img/404.jpg'" alt="什么是XSS和CSRF攻击"></a></div><div class="recent-post-info"><a class="article-title" href="/superjunjie/blog/2022/01/01/what-is-xss-csrf/" title="什么是XSS和CSRF攻击">什么是XSS和CSRF攻击</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2022-01-01T00:00:00.000Z" title="Created 2022-01-01 08:00:00">2022-01-01</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/superjunjie/blog/categories/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E5%85%A8/">浏览器安全</a></span></div><div class="content">XSS(跨站脚本攻击)XSS 攻击是指黑客往 HTML 文件中或者 DOM 中注入恶意脚本，从而在用户浏览页面时利用注入的恶意脚本对用户实施攻击的一种手段。
什么是xss攻击可以做哪些事情
通过恶意脚本窃取用户Cookie信息，然后通过XHR加上CORS将用户隐私信息发送到恶意服务器。
监听用户行为，可以通过监听用户输入获取用户银行卡密码。
可以通过修改 DOM 伪造假的登录窗口，用来欺骗用户输入用户名和密码等信息。
还可以在页面内生成浮窗广告，这些广告会严重地影响用户体验。

常见的XSS攻击类型存储型通过上图，我们可以看出存储型 XSS 攻击大致需要经过如下步骤：

首先黑客利用站点漏洞将一段恶意 JavaScript 代码提交到网站的数据库中；
然后用户向网站请求包含了恶意 JavaScript 脚本的页面；
当用户浏览该页面的时候，恶意脚本就会将用户的 Cookie 信息等数据上传到服务器。

反射型在一个反射型 XSS 攻击过程中，恶意 JavaScript 脚本属于用户发送给网站请求中的一部分，随后网站又把恶意 JavaScript 脚本返回给用户。当恶意 JavaScri ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/superjunjie/blog/2022/01/01/promise/" title="Promise实现"><img class="post_bg" src="/superjunjie/blog/./images/20221008123.webp" onerror="this.onerror=null;this.src='/superjunjie/blog/img/404.jpg'" alt="Promise实现"></a></div><div class="recent-post-info"><a class="article-title" href="/superjunjie/blog/2022/01/01/promise/" title="Promise实现">Promise实现</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2022-01-01T00:00:00.000Z" title="Created 2022-01-01 08:00:00">2022-01-01</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/superjunjie/blog/categories/%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0/">源码实现</a></span></div><div class="content">Promise历史回调函数的问题在Promise出现之前，JavaScript通过回调函数的方式实现异步，这样容易照成下面几点问题

层层的回调嵌套，导致变得异常难以理解，可维护性也变得很糟糕，曾作回调地狱
通过回调表达程序异步和管理并发的方式，导致程序执行的顺序不可控以及代码可信性度下降

Promise的解决方法Promise的出现解决了回调函数中因控制反转导致信任奔溃的问题，Promise通过实现对控制反转的再反转，实现对代码的控制，并将控制权交给我们，然后由我们自己的代码决定下一步做什么。Promise实现了链式调用，这样我们就可以通过链式的方式解决层层函数嵌套回调所带来回调地狱问题。
通过使用Promise，我们可以将原来传给第三方库或者函数调用的回调函数变成等待第三方库响应我们发出请求的值，在我们拿到值后，在决定怎么处理。这样的好处就是我们可以完全控制拿到第三方库或者函数处理值后的处理逻辑，使程序变得更加可控，可以减少因为回调函数不可信问题，写的冗余代码。
PromiseA+规范术语
Promise 是一个拥有 then 方法的对象或函数，其行为符合本规范；
具有then方 ...</div></div></div><nav id="pagination"><div class="pagination"><span class="page-number current">1</span></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/superjunjie/blog/img/avatar.jpg" onerror="this.onerror=null;this.src='/superjunjie/blog/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Jerry</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/superjunjie/blog/archives/"><div class="headline">Articles</div><div class="length-num">9</div></a><a href="/superjunjie/blog/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/superjunjie/blog/categories/"><div class="headline">Categories</div><div class="length-num">3</div></a></div><a id="card-info-btn" href="https://github.com/superjunjie"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/superjunjie" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:pcxiaoyan@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/superjunjie/blog/2022/01/06/function-overloading/" title="函数重载实现"><img src="/superjunjie/blog/./images/5.webp" onerror="this.onerror=null;this.src='/superjunjie/blog/img/404.jpg'" alt="函数重载实现"/></a><div class="content"><a class="title" href="/superjunjie/blog/2022/01/06/function-overloading/" title="函数重载实现">函数重载实现</a><time datetime="2022-01-06T00:00:00.000Z" title="Created 2022-01-06 08:00:00">2022-01-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/superjunjie/blog/2022/01/05/events-emitter/" title="发布订阅模式实现"><img src="/superjunjie/blog/./images/4.webp" onerror="this.onerror=null;this.src='/superjunjie/blog/img/404.jpg'" alt="发布订阅模式实现"/></a><div class="content"><a class="title" href="/superjunjie/blog/2022/01/05/events-emitter/" title="发布订阅模式实现">发布订阅模式实现</a><time datetime="2022-01-05T00:00:00.000Z" title="Created 2022-01-05 08:00:00">2022-01-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/superjunjie/blog/2022/01/04/deep-clone/" title="深拷贝实现"><img src="/superjunjie/blog/./images/3.webp" onerror="this.onerror=null;this.src='/superjunjie/blog/img/404.jpg'" alt="深拷贝实现"/></a><div class="content"><a class="title" href="/superjunjie/blog/2022/01/04/deep-clone/" title="深拷贝实现">深拷贝实现</a><time datetime="2022-01-04T00:00:00.000Z" title="Created 2022-01-04 08:00:00">2022-01-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/superjunjie/blog/2022/01/03/debounce-throttle/" title="节流防抖实现"><img src="/superjunjie/blog/./images/2.webp" onerror="this.onerror=null;this.src='/superjunjie/blog/img/404.jpg'" alt="节流防抖实现"/></a><div class="content"><a class="title" href="/superjunjie/blog/2022/01/03/debounce-throttle/" title="节流防抖实现">节流防抖实现</a><time datetime="2022-01-03T00:00:00.000Z" title="Created 2022-01-03 08:00:00">2022-01-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/superjunjie/blog/2022/01/02/array-op/" title="数组方法实现"><img src="/superjunjie/blog/./images/1.webp" onerror="this.onerror=null;this.src='/superjunjie/blog/img/404.jpg'" alt="数组方法实现"/></a><div class="content"><a class="title" href="/superjunjie/blog/2022/01/02/array-op/" title="数组方法实现">数组方法实现</a><time datetime="2022-01-02T00:00:00.000Z" title="Created 2022-01-02 08:00:00">2022-01-02</time></div></div></div></div><div class="card-widget card-categories"><div class="item-headline">
            <i class="fas fa-folder-open"></i>
            <span>Categories</span>
            
            </div>
            <ul class="card-category-list" id="aside-cat-list">
            <li class="card-category-list-item "><a class="card-category-list-link" href="/superjunjie/blog/categories/%E5%B7%A5%E5%85%B7%E6%96%B9%E6%B3%95/"><span class="card-category-list-name">工具方法</span><span class="card-category-list-count">7</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/superjunjie/blog/categories/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E5%85%A8/"><span class="card-category-list-name">浏览器安全</span><span class="card-category-list-count">1</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/superjunjie/blog/categories/%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0/"><span class="card-category-list-name">源码实现</span><span class="card-category-list-count">1</span></a></li>
            </ul></div><div class="card-widget card-archives"><div class="item-headline"><i class="fas fa-archive"></i><span>Archives</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/superjunjie/blog/archives/2022/01/"><span class="card-archive-list-date">January 2022</span><span class="card-archive-list-count">9</span></a></li></ul></div><div class="card-widget card-webinfo"><div class="item-headline"><i class="fas fa-chart-line"></i><span>Info</span></div><div class="webinfo"><div class="webinfo-item"><div class="item-name">Article :</div><div class="item-count">9</div></div><div class="webinfo-item"><div class="item-name">UV :</div><div class="item-count" id="busuanzi_value_site_uv"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">PV :</div><div class="item-count" id="busuanzi_value_site_pv"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">Last Push :</div><div class="item-count" id="last-push-date" data-lastPushDate="2022-12-08T13:43:58.579Z"><i class="fa-solid fa-spinner fa-spin"></i></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By Jerry</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/superjunjie/blog/js/utils.js"></script><script src="/superjunjie/blog/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>